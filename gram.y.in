
%{

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "taz.h"

#include "smach.h"
#include "backend.h"

int checknumU(int, int);
int checknumS(int, int);
int checknumW(int, int);
int checknumX(int, int);

extern int falseclause;
static struct symbol *label;
static int mac_argc;

extern struct mempool symbolnamepool;

#define MKICON(x)  mkicon((x))
#define MKLS1(x,y) mkls(M_LS1,(x),(y))
#define MKLS2(x,y) mkls(M_LS2,(x),(y))
#define MKADD(x,y) mkbinary(M_ADD,(x),(y))
#define MKSUB(x,y) mkbinary(M_SUB,(x),(y))
#define MKMUL(x,y) mkbinary(M_MUL,(x),(y))
#define MKDIV(x,y) mkbinary(M_DIV,(x),(y))
#define MKMOD(x,y) mkbinary(M_MOD,(x),(y))
#define MKAND(x,y) mkbinary(M_AND,(x),(y))
#define MKOR(x,y)  mkbinary(M_OR,(x),(y))
#define MKXOR(x,y) mkbinary(M_XOR,(x),(y))
#define MKSHL(x,y) mkbinary(M_SHL,(x),(y))
#define MKSHR(x,y) mkbinary(M_SHR,(x),(y))
#define MKNEG(x)   mkunary(M_NEG, (x))
#define MKCPL(x)   mkunary(M_CPL, (x))
#define MKNOT(x)   mkunary(M_NOT, (x))

%}

%union {
  numtype num;
  char *str;
  struct symbol *sym;
  SMV exp;
}

%token <str> T_LABEL T_SYMBOL
%token <num> T_NUMBER
%token <str> T_STRING
%token <str> T_MBODY T_MACARG
%token <sym> T_MAC

%token T_SECTION T_END
%token T_EQU T_SET T_INCLUDE T_INCDIR
%token T_MACRO T_ENDM T_MEXIT
%token T_ENDC T_IFD T_IFND T_IFC T_IFNC
%token T_IFEQ T_IFNE T_IFLT T_IFLE T_IFGT T_IFGE
%token T_EMA

<- opcodetokens ->
<- opertokens ->
<- stdtokens ->

%right T_COMPL T_NOT
%left  T_MUL T_DIV T_MOD
%left  T_ADD T_SUB
%left  T_SHL T_SHR
%nonassoc T_LT T_LE T_GT T_GE
%nonassoc T_EQ T_NE
%left  T_AND
%left  T_XOR
%left  T_OR

%type <str> section_name section_qualifier string
%type <num> conditional const_expr
%type <exp> expr

<- classtypes ->

%%

program : headers units opt_end

units : implicit_section
      | explicit_sections

explicit_sections : explicit_section
		  | explicit_sections explicit_section

explicit_section : section_header implicit_section

section_header : T_SECTION section_name
	       | T_SECTION section_name T_COMMA section_qualifier

section_name : T_SYMBOL

section_qualifier : T_SYMBOL

opt_end : T_END |

implicit_section : statement
		 | implicit_section statement

headers : header
	| headers header
	|

statement : header
	  | pseudo
	  | opcode
	  | T_LABEL {}

header : error
       | T_LABEL T_EQU
		{ if(!(label=create_symbol($1, SYMB_EQU))) YYERROR; }
	 const_expr
		{ label->value.num=$4; }
       | T_LABEL T_EQ
		{ if(!(label=create_symbol($1, SYMB_EQU))) YYERROR; }
	 const_expr
		{ label->value.num=$4; }
       | T_LABEL T_SET
		{ if(!(label=create_symbol($1, SYMB_SET))) YYERROR; }
	 const_expr
		{ label->value.num=$4; }
       | T_INCDIR T_STRING
		{ add_incdir($2); }
       | T_INCLUDE T_STRING
		{ if(!process_include($2))
			errormsg("Can't find include file %s", $2); }
       | conditional { if(!$1) falseclause=1;  } cond_block T_ENDC
	{ if(!$1) falseclause=0; }
       | T_LABEL T_MACRO 
		{ if(!(label=create_symbol($1, SYMB_MACRO))) YYERROR; }
	 T_MBODY T_ENDM
		{ label->value.macro=$4; }
       | T_MAC { mac_argc=0; } macargs_opt T_EMA
		{ invoke_macro($1, mac_argc); }
       | T_MEXIT { if(!abort_macro()) { errormsg("Spurious mexit"); YYERROR; }}
       | T_ENDC { errormsg("Spurious endc"); YYERROR; }
       | T_ENDM { errormsg("Spurious endm"); YYERROR; }

pseudo :

cond_block : cond_block statement
	   | 

conditional
	: T_IFD T_SYMBOL { $$ = !!lookup_symbol($2); }
	| T_IFND T_SYMBOL { $$ = !lookup_symbol($2); }
	| T_IFC string T_COMMA T_STRING { $$ = (strcmp($2, $4) == 0); }
	| T_IFNC string T_COMMA T_STRING { $$ = (strcmp($2, $4) != 0); }
	| T_IFEQ const_expr T_COMMA const_expr { $$ = $2==$4; }
	| T_IFNE const_expr T_COMMA const_expr { $$ = $2!=$4; }
	| T_IFLT const_expr T_COMMA const_expr { $$ = $2<$4; }
	| T_IFLE const_expr T_COMMA const_expr { $$ = $2<=$4; }
	| T_IFGT const_expr T_COMMA const_expr { $$ = $2>$4; }
	| T_IFGE const_expr T_COMMA const_expr { $$ = $2>=$4; }
	| T_IFEQ const_expr { $$ = $2==0; }
	| T_IFNE const_expr { $$ = $2!=0; }
	| T_IFLT const_expr { $$ = $2<0; }
	| T_IFLE const_expr { $$ = $2<=0; }
	| T_IFGT const_expr { $$ = $2>0; }
	| T_IFGE const_expr { $$ = $2>=0; }

macargs_opt
	: macargs
	|

macargs
	: macarg
	| macargs T_COMMA macarg

macarg	: T_MACARG
	{ macro_storearg(mac_argc++, $1); }

<- opcodeproductions ->

<- templateproductions ->
<- enumproductions ->
<- numericproductions ->

const_expr : expr { numtype n; if(evalconst($1, &n)) $$ = n; else { errormsg("Expression does not compute to a constant value"); YYERROR; } }

expr : T_LPAR expr T_RPAR { $$ = $2; }
     | T_NUMBER { $$ = MKICON($1); }
     | T_SYMBOL
	{ if((label=lookup_symbol($1))) $$=mksymbref(label); else if((label=create_symbol($1, SYMB_UNDEF))) $$=mksymbref(label); else YYERROR; }
     | T_SUB expr %prec T_NOT { $$ = MKNEG($2); }
     | T_ADD expr %prec T_NOT { $$ = $2; }
     | T_COMPL expr { $$ = MKCPL($2); }
     | T_NOT expr { $$ = MKNOT($2); }
     | expr T_ADD expr { $$ = MKADD($1,$3); }
     | expr T_SUB expr { $$ = MKSUB($1,$3); }
     | expr T_MUL expr { $$ = MKMUL($1,$3); }
     | expr T_DIV expr { $$ = MKDIV($1,$3); }
     | expr T_MOD expr { $$ = MKMOD($1,$3); }
     | expr T_AND expr { $$ = MKAND($1,$3); }
     | expr T_OR  expr { $$ = MKOR($1,$3); }
     | expr T_NOT expr %prec T_OR { $$ = MKOR($1,$3); }
     | expr T_XOR expr { $$ = MKXOR($1,$3); }
     | expr T_SHL expr { $$ = MKSHL($1,$3); }
     | expr T_SHR expr { $$ = MKSHR($1,$3); }

string : T_STRING
	{ $$ = poolstring(&symbolnamepool, $1); }

%%

int checknumU(int val, int bits)
{
  return val;
}

int checknumS(int val, int bits)
{
  return val;
}

int checknumW(int val, int bits)
{
  return val;
}

int checknumX(int val, int bits)
{
  return val;
}

void emit_16(int v)
{
  printf("EMIT: %04x\n", v&0xffff);
}
